var e=require("three"),n=require("dat.gui");module.exports=function(t,i,a,o){try{var l,r={multiply:!0,displacement:!0,displacementIntensity:.012,multiplyIntensity:-.15,blendOpacity:.95,rotation:-5,offsetX:17,offsetY:70,scale:.45},s=new n.GUI;s.add(r,"multiply"),s.add(r,"displacement"),s.add(r,"displacementIntensity",0,.02,.001),s.add(r,"multiplyIntensity",-.5,.5,.05),s.add(r,"blendOpacity",0,1,.05),s.add(r,"rotation",-10,10,.5).listen(),s.add(r,"offsetX",-200,200,1).listen(),s.add(r,"offsetY",-200,200,1).listen(),s.add(r,"scale",0,1,.01).listen();var c=new e.TextureLoader;c.crossOrigin="";var m=function(e){return new Promise(function(n,t){c.load(e,function(e){return n(e)},null,t)})};return Promise.resolve(m(t)).then(function(n){return Promise.resolve(m(i)).then(function(t){return Promise.resolve(m(a)).then(function(i){n.magFilter=n.minFilter=e.LinearFilter,t.magFilter=t.minFilter=e.LinearFilter,i.magFilter=i.minFilter=e.LinearFilter;var a=n.image.width/n.image.height,s=t.image.width/t.image.height,c=0,m=0,d=0,u=0;1==a?(c=1e3,m=1e3,u=1,d=1e3*s/1e3):a>1?(c=1e3*a,m=1e3,u=1,d=1e3*s/1e3):a<1&&(c=1e3,u=1/(1e3/(m=1e3/a)),d=m*s/1e3);var p=new e.Vector2(1e3/c,1e3/m),f=new e.Vector2((1-p.x)/2,(1-p.y)/2),v=function(n){return new e.Vector2(d*n,u*n)},y=function(e){return e/360*Math.PI*2},g=function(e){return e/1e3},h=new e.ShaderMaterial({uniforms:{displacementIntensity:{type:"f",value:r.displacementIntensity},mockup:{type:"t",value:n},design:{type:"t",value:t},designScale:{type:"vec2",value:v(r.scale)},offsetX:{type:"f",value:g(r.offsetX)},offsetY:{type:"f",value:g(r.offsetY)},mockupOffset:{type:"vec2",value:f},mockupSize:{type:"vec2",value:p},displacementMap:{type:"t",value:i},multiply:{type:"bool",value:r.multiply},multiplyIntensity:{type:"f",value:r.multiplyIntensity},blendOpacity:{type:"f",value:r.blendOpacity},displacement:{type:"bool",value:r.displacement},rotation:{type:"f",value:y(r.rotation)}},vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",fragmentShader:"\nvarying vec2 vUv;\n\nuniform sampler2D displacementMap;\nuniform sampler2D mockup;\nuniform sampler2D design;\nuniform bool multiply;\nuniform bool displacement;\nuniform float displacementIntensity;\nuniform float multiplyIntensity;\nuniform float blendOpacity;\nuniform vec2 designScale;\nuniform float rotation;\nuniform float offsetX;\nuniform float offsetY;\nuniform vec2 mockupOffset;\nuniform vec2 mockupSize;\n\nmat2 getRotM(float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return mat2(c, -s, s, c);\n}\n\nvec2 rotateUV(vec2 uv, float rotation, float mid) {\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nvoid main() {\n    // Translate mockup UVs to position mockup in render space. This UV is used for the mockup, and the mockup displacement map.\n    float mockupTranslatedX = vUv.x * mockupSize.x + mockupOffset.x;\n    float mockupTranslatedY = vUv.y * mockupSize.y + mockupOffset.y;\n    vec2 mockupTranslatedUV = vec2(mockupTranslatedX, mockupTranslatedY);\n\n    // Calculate displacement map vector.\n    vec4 displacementMapTex = texture2D(displacementMap, mockupTranslatedUV);\n    vec2 displacementVector = vec2(0,0);\n    if (displacement) {\n        displacementVector = vec2(displacementMapTex.r, displacementMapTex.g);\n    }\n\n    // Get offset translated UV\n    vec2 translatedUV = vUv - vec2(offsetX, offsetY);\n\n    // Get scaled design UV.\n    vec2 scaledDesignUV = (translatedUV - vec2(0.5)) * 1.0/designScale + vec2(0.5);\n\n    // Get rotated UV\n    vec2 rotatedUV = rotateUV(scaledDesignUV, rotation, 0.5);\n\n    // Use the grayscale constant (e.g. [170/255, 170/255]) to displace our UV coord.\n    vec2 distortedPosition = rotatedUV + displacementVector * displacementIntensity - vec2(displacementIntensity);\n\n    vec4 _mockup = texture2D(mockup, mockupTranslatedUV);\n    vec4 _design = texture2D(design, distortedPosition);\n\n    if (multiply) {\n        // Use multiply blending to merge the mockup and design textures.\n        vec3 blended = _mockup.rgb * (1.0 - _design.a) + ((_mockup.rgb - vec3(multiplyIntensity)) * _design.rgb * _design.a);\n        \n        vec3 blendedWithOpacity = blended * blendOpacity + _mockup.rgb * (1.0 - blendOpacity);\n        gl_FragColor = vec4(blendedWithOpacity, 1.0);\n\n    } else {\n        vec3 blended = _mockup.rgb * (1.0 - _design.a) + _design.rgb * _design.a;\n        gl_FragColor = vec4(blended, 1.0);\n    }\n}\n",transparent:!0,opacity:1}),k=new e.Scene,b=new e.OrthographicCamera(-500,500,500,-500,1,1e3);b.position.z=1;var U=new e.WebGLRenderer({antialias:!1,alpha:!0});U.setPixelRatio(2),U.setClearColor(16777215,0),U.setSize(1e3,1e3);var V=U.domElement;V.style.height=1e3,V.style.width=1e3,o.appendChild(V);var w=new e.PlaneBufferGeometry(1e3,1e3,1),x=new e.Mesh(w,h);k.add(x),l=function(){window.requestAnimationFrame(l),h.uniforms.multiply.value=r.multiply,h.uniforms.displacement.value=r.displacement,h.uniforms.displacementIntensity.value=r.displacementIntensity,h.uniforms.multiplyIntensity.value=r.multiplyIntensity,h.uniforms.blendOpacity.value=r.blendOpacity,h.uniforms.rotation.value=y(r.rotation),h.uniforms.offsetX.value=g(r.offsetX),h.uniforms.offsetY.value=g(r.offsetY),h.uniforms.designScale.value=v(r.scale),U.render(k,b)},window.requestAnimationFrame(l)})})})}catch(e){return Promise.reject(e)}};
//# sourceMappingURL=render-mockup.js.map
