import{TextureLoader as e,LinearFilter as n,Vector2 as t,ShaderMaterial as i,Scene as a,OrthographicCamera as o,WebGLRenderer as l,PlaneBufferGeometry as s,Mesh as r}from"three";import{GUI as c}from"dat.gui";export default function(m,d,u,p){try{var f,v={multiply:!0,displacement:!0,displacementIntensity:.012,multiplyIntensity:-.15,blendOpacity:.95,rotation:-5,offsetX:17,offsetY:70,scale:.45},y=new c;y.add(v,"multiply"),y.add(v,"displacement"),y.add(v,"displacementIntensity",0,.02,.001),y.add(v,"multiplyIntensity",-.5,.5,.05),y.add(v,"blendOpacity",0,1,.05),y.add(v,"rotation",-10,10,.5).listen(),y.add(v,"offsetX",-200,200,1).listen(),y.add(v,"offsetY",-200,200,1).listen(),y.add(v,"scale",0,1,.01).listen();var g=new e;g.crossOrigin="";var k=function(e){return new Promise(function(n,t){g.load(e,function(e){return n(e)},null,t)})};return Promise.resolve(k(m)).then(function(e){return Promise.resolve(k(d)).then(function(c){return Promise.resolve(k(u)).then(function(m){e.magFilter=e.minFilter=n,c.magFilter=c.minFilter=n,m.magFilter=m.minFilter=n;var d=e.image.width/e.image.height,u=c.image.width/c.image.height,y=0,g=0,k=0,b=0;1==d?(y=1e3,g=1e3,b=1,k=1e3*u/1e3):d>1?(y=1e3*d,g=1e3,b=1,k=1e3*u/1e3):d<1&&(y=1e3,b=1/(1e3/(g=1e3/d)),k=g*u/1e3);var h=new t(1e3/y,1e3/g),U=new t((1-h.x)/2,(1-h.y)/2),V=function(e){return new t(k*e,b*e)},w=function(e){return e/360*Math.PI*2},x=function(e){return e/1e3},I=new i({uniforms:{displacementIntensity:{type:"f",value:v.displacementIntensity},mockup:{type:"t",value:e},design:{type:"t",value:c},designScale:{type:"vec2",value:V(v.scale)},offsetX:{type:"f",value:x(v.offsetX)},offsetY:{type:"f",value:x(v.offsetY)},mockupOffset:{type:"vec2",value:U},mockupSize:{type:"vec2",value:h},displacementMap:{type:"t",value:m},multiply:{type:"bool",value:v.multiply},multiplyIntensity:{type:"f",value:v.multiplyIntensity},blendOpacity:{type:"f",value:v.blendOpacity},displacement:{type:"bool",value:v.displacement},rotation:{type:"f",value:w(v.rotation)}},vertexShader:"\nvarying vec2 vUv;\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n",fragmentShader:"\nvarying vec2 vUv;\n\nuniform sampler2D displacementMap;\nuniform sampler2D mockup;\nuniform sampler2D design;\nuniform bool multiply;\nuniform bool displacement;\nuniform float displacementIntensity;\nuniform float multiplyIntensity;\nuniform float blendOpacity;\nuniform vec2 designScale;\nuniform float rotation;\nuniform float offsetX;\nuniform float offsetY;\nuniform vec2 mockupOffset;\nuniform vec2 mockupSize;\n\nmat2 getRotM(float ang) {\n  float s = sin(ang);\n  float c = cos(ang);\n  return mat2(c, -s, s, c);\n}\n\nvec2 rotateUV(vec2 uv, float rotation, float mid) {\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\nvoid main() {\n    // Translate mockup UVs to position mockup in render space. This UV is used for the mockup, and the mockup displacement map.\n    float mockupTranslatedX = vUv.x * mockupSize.x + mockupOffset.x;\n    float mockupTranslatedY = vUv.y * mockupSize.y + mockupOffset.y;\n    vec2 mockupTranslatedUV = vec2(mockupTranslatedX, mockupTranslatedY);\n\n    // Calculate displacement map vector.\n    vec4 displacementMapTex = texture2D(displacementMap, mockupTranslatedUV);\n    vec2 displacementVector = vec2(0,0);\n    if (displacement) {\n        displacementVector = vec2(displacementMapTex.r, displacementMapTex.g);\n    }\n\n    // Get offset translated UV\n    vec2 translatedUV = vUv - vec2(offsetX, offsetY);\n\n    // Get scaled design UV.\n    vec2 scaledDesignUV = (translatedUV - vec2(0.5)) * 1.0/designScale + vec2(0.5);\n\n    // Get rotated UV\n    vec2 rotatedUV = rotateUV(scaledDesignUV, rotation, 0.5);\n\n    // Use the grayscale constant (e.g. [170/255, 170/255]) to displace our UV coord.\n    vec2 distortedPosition = rotatedUV + displacementVector * displacementIntensity - vec2(displacementIntensity);\n\n    vec4 _mockup = texture2D(mockup, mockupTranslatedUV);\n    vec4 _design = texture2D(design, distortedPosition);\n\n    if (multiply) {\n        // Use multiply blending to merge the mockup and design textures.\n        vec3 blended = _mockup.rgb * (1.0 - _design.a) + ((_mockup.rgb - vec3(multiplyIntensity)) * _design.rgb * _design.a);\n        \n        vec3 blendedWithOpacity = blended * blendOpacity + _mockup.rgb * (1.0 - blendOpacity);\n        gl_FragColor = vec4(blendedWithOpacity, 1.0);\n\n    } else {\n        vec3 blended = _mockup.rgb * (1.0 - _design.a) + _design.rgb * _design.a;\n        gl_FragColor = vec4(blended, 1.0);\n    }\n}\n",transparent:!0,opacity:1}),O=new a,_=new o(-500,500,500,-500,1,1e3);_.position.z=1;var T=new l({antialias:!1,alpha:!0});T.setPixelRatio(2),T.setClearColor(16777215,0),T.setSize(1e3,1e3);var S=T.domElement;S.style.height=1e3,S.style.width=1e3,p.appendChild(S);var F=new s(1e3,1e3,1),M=new r(F,I);O.add(M),f=function(){window.requestAnimationFrame(f),I.uniforms.multiply.value=v.multiply,I.uniforms.displacement.value=v.displacement,I.uniforms.displacementIntensity.value=v.displacementIntensity,I.uniforms.multiplyIntensity.value=v.multiplyIntensity,I.uniforms.blendOpacity.value=v.blendOpacity,I.uniforms.rotation.value=w(v.rotation),I.uniforms.offsetX.value=x(v.offsetX),I.uniforms.offsetY.value=x(v.offsetY),I.uniforms.designScale.value=V(v.scale),T.render(O,_)},window.requestAnimationFrame(f)})})})}catch(e){return Promise.reject(e)}}
//# sourceMappingURL=render-mockup.es.js.map
